package mimetic.desire.behaviour.ecj.problems;

import java.util.ArrayList;

import mimetic.desire.behaviour.FitnessBehaviour;
import mimetic.desire.behaviour.SocialFitnessBehaviour;

import org.apache.commons.math3.stat.descriptive.moment.GeometricMean;

import sim.util.Double2D;
import ec.EvolutionState;
import ec.Individual;
import ec.cgp.FitnessCGP;
import ec.cgp.genome.CGPIndividual;

/**
 * This problem is used to evaluate a set of controlling programs for an agent.
 * 
 * 
 * 
 * @author Davide Nunes
 * 
 */
public class FitnessExploitation extends AbstractEvoBehaviourProblem {
	private static final long serialVersionUID = 1L;

	@Override
	public void evaluate(EvolutionState state, Individual ind,
			int subpopulation, int threadnum) {

		ArrayList<Double> fitnessProgression = ((FitnessBehaviour) super.behaviour)
				.getFitnessProgressionRecords((CGPIndividual) ind);

		ArrayList<Double> fitnessR = ((SocialFitnessBehaviour) super.behaviour)
				.getFitnessRecord((CGPIndividual) ind);

		if (fitnessProgression == null) {
			throw new RuntimeException(
					"FitnessExploitation Problem is trying to retrieve a fitness record for an individual that was not evaluated, probably, evolve was called before all the controllers could be evaluated");
		} else {
			double fithessProg = 0;
			float fitnessV = 0;

			double[] progressions = new double[fitnessProgression.size()];

			// geometric mean is more appropriate to measure rates of growth
			GeometricMean progMean = new GeometricMean();

			// fithessProg =
			// progMean.evaluate(fitnessProgression.<Double>toArray(progressions));

			int i = 0;
			for (Double f : fitnessR) {
				progressions[i++] = f;
			}

			fithessProg = progMean.evaluate(progressions);

			// (fitnessV + (fithessProg * 1 / agent.steps)
			// fitness progression over time is valued
			// float fitness = (float) (1 /
			// (model.space.tds(agent.getPosition(),
			// new Double2D(model.bestPosition)) + 0.01));

			// distance to global over time as a fitness
			double fitness = (-1 * ((FitnessBehaviour) behaviour).distanceToGlobal);

			// instead of mean try the last value ending up in a good fitness
			// fitness = (float) (1.0 * fitnessRecord
			// .get(fitnessRecord.size() - 1));

			// change false to the condition of being ideal
			((FitnessCGP) ind.fitness)
					.setFitness(state, (float) fitness, false);
			ind.evaluated = true;
		}

	}
}
